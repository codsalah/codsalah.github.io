<!-- Table of Contents -->
<div class="table-of-contents" id="toc-container">
  <div class="toc-header">
    <h3>Table of Contents</h3>
    <button class="toc-toggle" id="toc-toggle" aria-label="Toggle table of contents">
      <span class="toc-toggle-icon">−</span>
    </button>
  </div>
  <ul id="toc-list" class="toc-list">
    <!-- TOC will be generated by JavaScript -->
  </ul>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Generate table of contents from markdown headings
    const tocContainer = document.getElementById('toc-container');
    const tocList = document.getElementById('toc-list');
    const tocToggle = document.getElementById('toc-toggle');
    const tocToggleIcon = document.querySelector('.toc-toggle-icon');

    // Toggle functionality for mobile
    tocToggle.addEventListener('click', function () {
      const isCollapsed = tocList.classList.contains('collapsed');

      if (isCollapsed) {
        tocList.classList.remove('collapsed');
        tocToggleIcon.textContent = '−';
        tocToggle.setAttribute('aria-expanded', 'true');
      } else {
        tocList.classList.add('collapsed');
        tocToggleIcon.textContent = '+';
        tocToggle.setAttribute('aria-expanded', 'false');
      }
    });

    // Auto-collapse on mobile
    function handleResize() {
      if (window.innerWidth <= 768) {
        tocList.classList.add('collapsed');
        tocToggleIcon.textContent = '+';
        tocToggle.setAttribute('aria-expanded', 'false');
      } else {
        tocList.classList.remove('collapsed');
        tocToggleIcon.textContent = '−';
        tocToggle.setAttribute('aria-expanded', 'true');
      }
    }

    // Initial check and resize listener
    handleResize();
    window.addEventListener('resize', handleResize);

    // Try multiple selectors to find the content area
    let postContent = document.querySelector('.post-content');
    if (!postContent) {
      postContent = document.querySelector('main');
    }
    if (!postContent) {
      postContent = document.querySelector('article');
    }
    if (!postContent) {
      postContent = document.body;
    }


    // Find headings from h1 to h3 only (# ## ###)
    const allHeadings = postContent.querySelectorAll('h1, h2, h3');

    // Filter out the main title (usually the first h1 or any h1 with class 'title')
    const headings = Array.from(allHeadings).filter((heading, index) => {
      // Skip if it's the main title
      if (heading.classList.contains('title')) {
        return false;
      }
      // Skip the first h1 if it appears to be the main title
      if (heading.tagName === 'H1' && index === 0) {
        return false;
      }
      return true;
    });

    if (headings.length > 0) {
      let tocHTML = '';
      let currentLevel = 1; // Default starting level

      // Determine the minimum level to normalize nesting
      const minLevel = Math.min(...headings.map(h => parseInt(h.tagName.charAt(1))));
      currentLevel = minLevel;

      headings.forEach(function (heading, index) {
        const headingText = heading.textContent.trim();
        const level = parseInt(heading.tagName.charAt(1));

        const anchorId = 'toc-' + headingText.toLowerCase()
          .replace(/[^\w\s\u00C0-\u017F\u0600-\u06FF-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '')
          + '-' + index;

        heading.id = anchorId;

        if (level > currentLevel) {
          // Open nested lists
          for (let i = currentLevel; i < level; i++) {
            tocHTML += '<ul class="toc-nested">';
          }
        } else if (level < currentLevel) {
          // Close nested lists
          for (let i = level; i < currentLevel; i++) {
            tocHTML += '</ul>';
          }
        }

        tocHTML += `
          <li class="toc-level-${level}">
            <a href="#${anchorId}" data-target="${anchorId}" class="toc-link">
              <span class="toc-text">${headingText}</span>
            </a>
          </li>
        `;
        currentLevel = level;
      });

      // Close all open lists
      for (let i = minLevel; i < currentLevel; i++) {
        tocHTML += '</ul>';
      }

      tocList.innerHTML = tocHTML;

      // Add smooth scrolling and active state management
      const tocLinks = tocList.querySelectorAll('.toc-link');
      let activeLink = null;

      tocLinks.forEach(function (link) {
        link.addEventListener('click', function (e) {
          e.preventDefault();
          const targetId = this.getAttribute('data-target');
          const targetElement = document.getElementById(targetId);

          if (targetElement) {
            // Remove active class from all links
            tocLinks.forEach(l => l.classList.remove('active'));
            // Add active class to clicked link
            this.classList.add('active');
            activeLink = this;

            // Smooth scroll with offset for fixed headers
            const offset = 80; // Adjust based on your header height
            const elementPosition = targetElement.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - offset;

            window.scrollTo({
              top: offsetPosition,
              behavior: 'smooth'
            });

            // Add highlight effect
            targetElement.style.backgroundColor = 'rgba(255, 89, 125, 0.1)';
            targetElement.style.transition = 'background-color 0.3s ease';
            setTimeout(() => {
              targetElement.style.backgroundColor = '';
            }, 2000);
          }
        });
      });

      // Highlight current section on scroll
      function highlightCurrentSection() {
        const scrollPosition = window.scrollY + 100; // Offset for better UX

        let currentSection = null;
        headings.forEach(function (heading) {
          if (heading.offsetTop <= scrollPosition) {
            currentSection = heading;
          }
        });

        if (currentSection && currentSection.id) {
          const currentLink = document.querySelector(`a[data-target="${currentSection.id}"]`);
          if (currentLink && currentLink !== activeLink) {
            tocLinks.forEach(l => l.classList.remove('active'));
            currentLink.classList.add('active');
            activeLink = currentLink;
          }
        }
      }

      // Throttled scroll listener for performance
      let scrollTimeout;
      window.addEventListener('scroll', function () {
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
        scrollTimeout = setTimeout(highlightCurrentSection, 50);
      });

      // Show TOC container
      tocContainer.style.display = 'block';

    } else {
      // Hide TOC if no headings found
      tocContainer.style.display = 'none';
    }
  });
</script>